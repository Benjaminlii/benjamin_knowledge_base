# JVM

------

[TOC]

-------

##  1. GC

[Minor GC、Major GC、Full GC、分配担保](https://blog.csdn.net/aixls80424/article/details/101835017)

### (1). 什么是GC

​		GC就是垃圾回收机制.Java在JVM中实现了自动的对象内存回收.

### (2). 什么时候发生GC

宏观上看,GC是不可估计的,是由系统自身的运行状态决定的,或者程序调用System.GC().

微观上看,现在的虚拟机大多使用分代收集算法,所以GC可以分为Minor GC(新生代gc)和Full GC(完整GC).

>   Java堆中分为新生代和老年代,一般比例为1:3(可以通过JVM参数进行修改).
>
>   新生代中使用改进后的复制算法,将新生代分为一个Eden和两个Survivor区(SurvivorFrom和SurvivorTo,分别代表正在使用的Survivor和闲置的Survivor区),比例为8:1:1.
>
>   老年代使用标记算法进行GC.

#### 1). Minor GC

​		使用复制算法,针对新生代

>   空间分配担保机制:
>
>   ​		在进行Minor GC之前,会判断新生代所有对象的和是否能在了老年代中找出一个连续最大内存放下.如果可以,那么就是安全的GC(即Minor GC中如果剩余的空间和大于Survivor空间,就会放入老年代中),如果不可以,判断JVM设置是否允许担保.
>
>   ​		如果==允许担保==,那么将 老年代最大可用的连续空间 和 之前晋升到老年代中的空间大小的平均值 进行比较.如果老年代剩余空间比较大,那么==进行担保,进行冒险GC==.
>
>   ​		如果==不允许担保或者老年代不进行担保==,那么进行==Full GC==(在老年代中腾出空间存放Survivor区域的对象).
>
>   ​		冒险GC完成,那么==担保成功,结束GC==.如果冒险GC失败,那么==担保失败,进行Full GC==腾空间.
>
>   ​		如果Full GC后还是不能放得下Minor GC多余的空间,那么说明虚拟机的内存不够用了,抛异常.

1.  大多数对象都是朝生夕灭的,一般都会出现在新生代中的Eden区中.(大对象,超出Eden区大小适合所有收集器,可能会直接进入老年代)
1.  每当Eden区中产生对象时,都会检查Eden区能否放得下这个对象,如果可以,那么顺利的生成一个对象,如果不可以,那么进行一次Minor GC.
1.  在进行Minor GC前会进行空间分配担保
    1.  如果老年代中有足够大的连续空间能放得下当前新生代中所有对象,那么任务这个Minor GC是安全的,正常进行
        1.  在这期间如果Survivor空间不够放置存活的所有对象,那么把放置不下的对象放入老年代中的连续空间中(保证Minor GC是一定可以完成的)
    1.  如果没有这样的连续空间,那么查看是否允许担保
        1.  如果允许担保,那么将 老年代最大可用的连续空间 和 之前晋升到老年代中的空间大小的平均值 进行比较.如果老年代剩余空间比较大,那么进行担保,进行冒险GC.不允许担保则直接Full GC.
        1.  ,担保也就是进行冒险的GC,那么进行这次Minor GC
            1.  成功则担保成功,GC顺利结束
            1.  失败则担保失败,进行Full GC,去在老年代中清理出足够大的空间.
        1.  如果不允许担保失败,就直接循环进行Full GC,直到有足够大的连续空间为止
1.  Minor GC后至少腾出了Eden空间进行放置对象(所有的收集器都会把大于Eden区的对象直接放入老年代).

![image-20200314235108673](/home/benjamin/.config/Typora/typora-user-images/image-20200314235108673.png)

#### 2). Full GC

​		完整GC,收集新生代和老年代也就是整个堆空间的内存.使用标记算法.

>   对象的晋升:
>
>   ​		在新生代中,对象每经历一次Minor GC,年龄就会加一.当对象的年龄超过15岁(默认值,可以通过参数更改)时,就会在本次Minor GC中被晋升到老年代.
>
>   ​		还有一种动态对象年龄判定:当同一个年龄的对象空间总和达到Survivor空间的一半时,大于等于这个年龄的所有对象对会被晋升.

1.  老年代的对象由新生代晋升或者大对象直接进入
1.  当升入老年代的对象大于老年代剩余空间时,发生Full GC,清理后将对象放入老年代.如果清理后还是放不下,那么触发OOM异常.
1.  由于空间分配担保机制出发的强制Full GC(不允许担保,判断后不进行担保或者担保失败后)视为了给新生代Survivor去放不下的对象腾出空间.如果进行过后还是腾不出足够的空间,那说明老年代快被占满了,会抛异常.

### (3). 回收策略(垃圾回收算法)

#### 1). 标记-清除算法

​		标记清除法在GC过程中会==对存活的对象进行标记==,这个标记的过程的全局停止的.标记完成之后,统一对==没有标记的对象==进行回收.

​		缺点:会产生内存碎片,效率不高.

#### 2). 标记-整理算法

​		在GC过程中先将所有存活的对象移动到内存的一侧,全部扫描一遍之后,将这个边界以外的内存全部清除掉.

​		优点:不会产生内存碎片

​		缺点:移动对象需要更新引用,会全局停止

#### 3). 复制算法

​		将内存一分为二,每次使用其中的一块,GC时将使用中的内存中的存活的对象移动到另一块内存中,然后使用另一块内存作为运行时内存,清除掉原来的内存.

​		优点:不会产生内存碎片.

​		缺点:浪费内存.

​		改进就是Eden+SurvivorFrom+SurvivorTo

#### 4). 分代收集

​		现在的垃圾收集大多都是分代收集,新生代使用优化的复制算法,老年代使用两种标记算法之一.

### (4). 对什么进行GC

​		GC主要是对系统不再需要的对象进行的.一般要判断对象是否需要被清除(即死亡),有两种方法:==引用计数法==和==可达性分析==.

#### 1). 引用计数法

​		给每一个对象都增加一个计数器,计数器记录了这个对象被引用的次数,当这个计数器为0时,说明这个对象不会再被找到了.也就需要被清除了.

​		不足就是无法解决两个死亡对象相互引用的情况.

#### 2). 可达性分析

​		通过一系列GC Root(虚拟机栈中的对象,类静态属性,常量,本地方法栈中的对象)为起点,向下进行搜索,走过的路径为引用链.一个对象如果不在任何一个GC Root的引用链上,那么就说明这个对象不会再被使用了,要被清除.

#### 3). finalize()中的自我拯救

​		在GC要清除一个对象时,会先判断这个对象的finalize()方法是否需要被执行(即重写了且没被执行),如果是,那么在执行这个对象的finalize()方法.如果在执行过程中这个对象成功给自己关联了一条引用链,就被拯救了.

​		这个方法只执行一次.

>   虚拟机会把要执行finalize()方法的对象放入一个叫F-Queue的队列中,然后在一个优先级很低的线程中去执行这个队列中的所有对象的finalize()方法.

### (5). 安全点和安全区域

#### 1). 安全点

​		从线程角度看，safepoint可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的，如果有需要，可以在这个位置暂停，比如==发生GC时，需要暂停所有活动线程，但是该线程在这个时刻，还没有执行到一个安全点，所以该线程应该继续执行，到达下一个安全点的时候暂停，然后才开始GC，该线程等待GC结束==。

​		安全点的选定是以“==是否具有让程序长时间执行的特性==”为标准.如方法调用，循环跳转，异常跳转等。所有这些功能的指令才会产生安全点。

​		在gc发生时让所有线程跑到最近的安全点后停顿。
​		两种思路：
​		第一种,==抢先式中断==,GC发生时，让所有线程中断，如果有线程不在安全点，那么让线程跑到安全点。
​		第二种,==主动式中断==，设置一个标识，各个线程执行时不断轮询这个标志，发现标志时就自动挂起，轮询标志的地方和安全点重合。

#### 2). 安全区域

​		安全区域是指在一段代码片段中，引用关系不会发生变化，在该区域的任何地方发生GC都是安全的。

​		当代码执行到安全区域时，首先标示自己已经进入了安全区域，那样如果在这段时间里JVM发起GC，就不用管标示自己在安全区域的那些线程了，在线程离开安全区域时，会检查系统是否正在执行GC，如果是那么就等到GC完成后再离开安全区域。

### (6). 直接内存的回收

​		直接内存中的垃圾是通过GC回收的，不过GC只会在老年区满了触发Full GC时，才会去顺便清理直接内存的废弃对象

### (7). GC诊断调优

​		GC诊断可以通过jstat工具实现,可以查看堆的状态和GC信息的统计.

​		GC调优主要是对内存大小的分配,各个分区的比例进行修改.

### (8). 引用

#### 1). 强引用(Strong Reference)

​		强引用就是指程序代码中普遍存在的变量到对象的引用.类似`Object obj = new Object();`

​		**只要强引用还在,GC就不会回收这个对象**.

#### 2). 软引用(Soft Reference)

​		软引用来描述非必须但还可能有用的对象,**如果即将发生内存溢出,GC会清理这部分的内存**,如果清理过后还是会发生内存溢出,才会抛出异常.

#### 3). 弱引用(Weak Reference)

​		弱引用与软引用功能类似,只不过强度更弱.只能存活到下一次GC之前.**只要发生GC,就会清理弱引用**.

#### 4). 虚引用(Phantom Reference)

​		虚引用是最弱的引用关系,**唯一目的就是在这个对象被GC回收时能收到一个系统通知**.

​		==无法通过虚引用来获取一个对象的实例(get()方法返回为null)==

>   -   一般用来跟踪垃圾回收过程，在对象被垃圾回收时收到一个系统消息。程序可在收到某个虚引用对象被回收的消息 后做相应的措施。
>   -   ==当垃圾回收其准备回收一个对象时，如果发现这个对象存在虚引用，就会在垃圾回收前将这个对象的虚引用加入到引用队列中。==
>   -   可以通过检查引用队列中是否有相应的虚引用来判断对象是否被回收。
>   -   ==在其关联的虚引用出队之前，是不会销毁该对象的。==（使用 poll() 方法从应用队列中出队一个虚引用，虚引用出队后，与之关联的对象才可能会被销毁。==使用虚引用的目的就是为了得知对象被GC的时机，所以可以利用虚引用来进行销毁前的一些操作，比如说资源释放等。==）
>   -   如果一个对象没有强引用和软引用，对于垃圾回收器而言便是可以被清除的，在清除之前，会调用其finalize方法，如果一个对象已经被调用过finalize方法但是还没有被释放，它就变成了一个虚可达对象。
>   -   与软引用和弱引用不同，显式使用虚引用可以阻止对象被清除，只有在程序中显式或者隐式移除这个虚引用时，这个已经执行过finalize方法的对象才会被清除。想要显式的移除虚引用的话，只需要将其从引用队列中取出然后扔掉（置为null）即可。

### (9). 串行GC、并行回收GC、并行GC

-   串行GC
    -   在整个扫描和复制过程采用单线程的方式来进行，适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式.
-   并行GC
    -   在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式