# 操作系统面试中常见问题总结

-----

[toc]

-----

## 1. unix下进程间通信方式

### (1). 管道(pipe)：

> unix系统最古老的通信方式
>
> 半双工（数据单向流动，固定读端和写端）
>
> 只能用于有亲密关系的进程之间的通信（父子进程，兄弟进程）

### (2). 命名管道(FIFO)：

> 提供一个路径名与管道关联，只要能访问这个路径，就可以通过FIFO相互通信。
>
> 值得注意的是，FIFO(first input first output)总是按照==先进先出==的原则工作，第一个被写入的数据将首先从管道中读出。

### (3). 消息队列：

> 消息的链接表，由一个id标识。
>
> 独立于发送和接收进程。
>
> 消息可以随机查询，不一定要先进先出（，同一个消息队列支持不同类型的消息，可以按照固定的消息类型读取）

### (4). 信号量：

> 一个计数器，用于和PV操作一起实现进程间的互斥和同步。
>
> 不能传递复杂消息。

### (5). 共享内存：

> 指两个或者多个进程共享一个给定的存储区。
>
> 是最快的一种通信方式，但因为多个进程可以同时操作，需要进行同步。
>
> 信号量+共享内存常常一起使用。

## 2. 进程和线程

### (1). 进程

> 是指在系统中正在运行的一个应用程序，程序一旦运行就是进程。从内核观点来看，进程是担当分配系统资源（CPU时间，内存等等）的基本单位。

### (2). 线程

> 是系统分配CPU时间的基本单元，是程序执行的最小单位。

### (3). 区别

1. 进程拥有独立的堆栈空间和数据段，每启动一个新的进程都必须给它分配独立的地址空间，系统开销很大。而线程共享所属进程的所有数据段，比进程更节俭，开销较小。
2. 进程之间相互独立，所以安全性较高，一个进程崩溃后，其他进程不受影响。而一个线程死掉就等于所属的这个进程死掉。
3. 通信机制上，进程之间相互独立，通信更加复杂，管道、信号、消息队列、共享内存。而线程之间要简单很多（锁机制、信号量机制，基本上都是用于线程间同步，不用于数据交换）
4. 多个线程可以并行执行（多核CPU）

## 3. 进程有哪些状态

​		五态中包含：创建、就绪、运行、阻塞和终止。

​		运行态就是正在被处理的进程的状态。就绪态是所有资源都准备好了，即将被CPU调度的进程的状态。阻塞态是进程因为某一事件而暂停运行，即使CPU空闲，也不可运行。

> 运行态 -> 阻塞态：往往是等待外设，等待内存等资源分配而引起的。
>
> 阻塞态 -> 就绪态：等待的条件已满足，只需要等待处理器调度就可以运行。
>
> 运行态 -> 就绪态：由于其他原因，当前进程让出CPU的执行权，如时间片轮转和高优先级进程抢占CPU。
>
> 就绪态 -> 运行态：系统按照某种策略选中就绪队列中的某个进程分配CPU的使用权，此时变成运行态。

## 4. 进程调度算法有哪些

1. 先来先服务 FCFS：就绪队列按照进程到达的顺序排列。

2. 短作业优先 SJF：就绪队列中按照作业执行的时间排序。长作业可能会饥饿。

3. 高相应比优先 HRRN：每次选择相应比最高的进程执行。相应比 = (等待时间 + 作业耗时) / 作业耗时

4. 时间片轮转 RR：按照固定的时间片去轮流执行队列中的每一个进程（按照作业到达的顺序执行）。

5. 优先级调度算法：就绪队列中按照进程的优先级进行排列，低优先级进程可能饥饿。

6. 多级反馈队列：

    > 设置n个队列，序号小的队列优先级高。
    >
    > 每一个队列都有自己的时间片大小，每调度一次，让一个进程执行一个时间片。
    >
    > 前n-1个队列中使用FCFS进行调度，第n个队列使用RR调度。
    >
    > 当高优先级的队列为空时才会执行较低优先级队列中的进程。（每一次调度从上向下找）
    >
    > 一个进程执行完一个时间片后如果没有结束任务，那么将其降级。直到在最低一级的队列中一直使用RR调度。

## 5. 什么是死锁

​		多个并发进程中每个进程都持有某种资源，但是又同时在等待别的资源，相互等待，都不能运行，这种情况被称为死锁。

### (1). 死锁产生的条件

1. 互斥：一个资源某一时刻只能被一个进程使用。
2. 请求与保持：一个进程阻塞时，不会释放自身已经拥有的资源。
3. 不可剥夺：一个进程不能强行获得其他进程的资源
4. 循环等待：若干进程形成头尾相接的等待链。

## 6. 虚拟内存

### (1). 概念

​		在进行装入时,只将很快会用到的部分内存装入内存,暂时用不到的内存留在外存中.当要访问的信息不在内存中时,操作系统将其从外存中调入内存.当内存空间不够时,操作系统负责将暂时不用的内存换出外存.

​		在用户看来,似乎能加载很多的内存,这就是虚拟内存.

​		虚拟内存中,内存管理是离散分配的,因为内存的调入是不同时进行的,要进行连续分配不现实.

​		页表中新增了状态位(是否已经调入内存),访问字段(最近被访问的次数或者时间),修改位(是否被修改,决定下一次是否覆盖页面中的旧数据),外存地址.

### (2). 页面置换算法

1. 最佳置换算法 OPT：选择之后最长时间不会被使用的内存置换出去。不可能实现。

2. 先进先出置换算法 FIFO：选择当前内存中最早被加载进来的内存置换出去。性能较差。

3. 最近最久未使用算法 LRU：选择当前内存中最久未使用的内存置换出去。

    > 双向链表+字典实现。
    >
    > 双向链表作为队列使用，按照内存块空闲的时间维护内存块之间的次序关系。
    >
    > 每次使用到一块内存时，根据字典查找到队列中的节点，放到队列尾。
    >
    > 这样队列首一定时所有内存中最久未使用的内存块。

4. 时钟置换算法 CLOCK：每一个内存块增加最近是否被使用标记。被使用时打标。需要进行置换时，扫描所有内存，如果内存被达标，那么清楚标记。如果没被达标，那么选择这块内存进行置换。