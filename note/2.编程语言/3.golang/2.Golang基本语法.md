# 二. Golang基本语法

-----

[toc]

-----

## 1. 变量

变量的含义和其他常见的编程语言一样，是用于存储值的一个桶。

变量使用的基本步骤：声明，赋值，使用

### (1). 变量有类型

变量的类型通过==推导==或者在==变量名后声明==进行确定

在声明变量的时候统一使用关键字==var==

### (2). 变量使用的三种方式

1. 指定变量类型，如果不直接初始化，那么使用默认值

    ```go
    var num int // 这里会填充为0
    ```

2. 根据值自动判定变量类型

    ```go
    var num = 100 // 这里根据100的值推导出变量num的类型为int
    ```

3. 使用:=来省略var关键字

    ```go
    num := 100 // 这里的:=相当于声明并赋值，这时可以省略var关键字
    ```

### (3). 一次声明多个变量

Go语言支持一条语句声明多个变量

```go
// 注意在使用前一定要进行初始化，所以这里最好统一进行初始化或者声明其类型进行默认的初始化
var num1, num2, num3 int
// 手动进行初始化使用下面的写法
var num1, num2, num3 = 1, 2, 3
// 或者使用类型推导
num1, num2, num3 := 1, 2, 3
```

### (4). 全局变量的声明

同其他语言一样，全局变量就是整个程序中都可以使用的变量，类比C语言中的全局变量。

单个全局变量的声明方式很简单，多个全局变量的声明方式有一些特殊。

```go
// 单个全局变量的声明就是在函数体之外进行了变量的声明
// 多个全局变量的声明也是如此，但是有一种简便的声明方式
var (
    globalNum1 = 1
    globalNum2 = 2
)
```

### (5). 变量的范围

变量一经确认类型，就只能在这个类型允许的范围内进行变化，而不能像python一样进行任意的转化

### (6). 变量的作用域

函数内部声明的变量叫局部变量，仅能在当前函数内部使用。

函数外部声明的变量叫全局变量，作用域是整个包，==当其首字母大写时，整个程序有有效==。

如果一个变量声明在一个代码块中，那么它仅仅在代码块内部有效。

## 2. 变量的数据类型

> 在程序中, 可以通过下面的方式来输出变量的类型:
>
> fmt.Printf("num的类型是%T, num占用的字节数是%d", num, unsafe.Sizeof(num))

### (1). 基本数据类型

> 基本数据类型通常分配在栈空间

- 数值型
    - 整数类型：int, int8, int32, int64, uint, uint8, uint32, uint64, byte, rune(分别代表有无符号的各个长度的int, byte和uint8等价, int在32位机位int32, 在64位机为int64, rune等价int32, 可用于表示一个Unicode码)
    - 浮点类型：float32，float64
- 字符型：无专门的字符类型
    - 使用byte来表示单个的字符, 汉字字符3字节要选择合适的类型进行存储
    - 要输出字符需要使用==fmt.Printf==来进行打印
    - Go语言字符使用UTF-8编码
    - 默认为空串""
- 布尔型：bool, 1字节, 只能为true或者false, 可直接打印
- 字符串：string(==Go中字符串是基本数据类型==),
    - Golang中的字符串是由==字节==组成的(也就是一串连续的字节数据,使用UTF-8编码解析就可以得到字符串，一般字符占1字节，中文等占3字节), 这样的话使用下标去访问其中的每一个字符就不能兼顾所有的字符。
    - 跟其他编程语言一样, Go中的字符串string一经赋值就不可以再被更改了
    - 使用反引号`(左上角)即可不进行转义,原文输出
    - 可以使用+加号进行字符串的拼接, 多行的拼接要将加号放在上一行

> 基本数据类型的转换：
>
> Golang中的数据类型不能自动转换，所有精度的数据类型之间的转换都需要强制转换，语法如下：
>
> ```go
> // 将变量v1转换为类型T，作为临时值使用，并赋值给变量v2
> var v2 T = T(v1)
> ```
>
> 在转换过程中如果类型的范围不能存储的下数据，那么按溢出处理（也就是只截取后面相应位的数据）
>
> 基本数据类型转string类型：
>
> 方法一：fmt.Sprintf("%参数", 表达式)，这个方法会返回转换后的string变量
>
> 相当于是格式化输出，但是将要打印的字符串作为返回值返回
>
> ```go
> // %q 相当于 字符串的带引号填充
> str := fmt.Sprintf("%d.%d.%d %d:%d:%d", 2020, 4, 15, 18, 10, 00)
> ```
>
> 方法二：使用strconv包的FormatXXXXXX函数
>
> ```go
> // FormatInt(要转换的值 int64，要转换的进制)
> fmt.strconv.FormatInt(127, 2)
> 
> // FormatFloat(要转换的值（float64），
> //             要转换的格式（byte类型，常用'f'十进制，'b'二进制，'E'指数），
> //             精度（小数点后的位数）,
> //             f的来源类型（32：float32、64：float64）) string
> strconv.FormatFloat(127.123456789, 'f', 6, 32)
> 
> // FormatBool(要转换的值（bool）)
> strconv.FormatBool(true)
> ```
>
> string转基本数据类型：
>
> 使用strconv包的ParseXXXXXXX函数来完成，需要注意字符串的内容，如果不能成功转化，那么会返回默认值，并附加上错误
>
> ```go
> // ParseInt 参数：字符串，进制，整数的类型
> strconv.ParseInt("123", 10, 64)
> // ParseFloat 参数：字符串，浮点数的类型
> strconv.ParseFloat("123.456789", 32)
> // ParseBool 参数：字符串
> strconv.ParseBool("true")
> ```

### (2). 引用类型

> 引用类型存储的是实际数据的地址，实际的数据通常存在堆空间。当没有任何引用指向一片空间时，这部分内存会被GC清理。
>
> 当然也有逃逸分析，所以也有可能分配在栈空间上。

- 指针(Pointer)

    - 大致上都与C中的指针相同，但是有一个细节

        ```go
        // 在下面，两个*的意义是不同的
        // 声明一个指针
        var num int = 100
        var p *int = &num
        // 间接访问这个指针的内容
        fmt.Println(*p == num)
        ```

    - 每一种类型都有对应的指针

- 数组

- 结构体(struct)：可以类比class

- 管道(Channel)：并发中使用

- 函数

- 切片(slice)：动态数组

- 接口(interface)：类似其他语言中的接口

- map

## 3. 运算符

这里只写出特殊的使用，其他部分都与Java相同

| 运算符        | 含义                                         |
| ------------- | -------------------------------------------- |
| +             | 加法运算或者字符串拼接（两侧都必须是字符串） |
| ++ --         | 只能放在变量后面使用，并且==只能独立使用==   |
| &             | 取地址符，同C语言                            |
| *             | 间接访问或者指针的声明                       |
| \>\>\> \<\<\< | 不存在无符号位移运算符                       |
| ?:            | 不存在三目运算符                             |

## 4. 标识符

### (1). 命名规范

对于==变量名==的命名规范大致上与C语言等同，==下划线_单独出现是作为空标识符==，仅能作为占位符使用。

==package的名字要和目录保持一致==，尽量简短，有意义，并且不和标准库冲突。

> 一个目录下，包名个需要和目录名一致，或者只能是main包。main包中的每一个源文件都至多能有一个main函数。main函数可以作为局部程序的测试或者整个程序的入口

变量名，函数名，常量名等等使用==驼峰命名法==。==如果首字母大写了，那么可以被其他包访问，相当于public==。

### (2). 系统保留关键字

就是不可以再被自定义为表示符的关键字。如break，defaule，func，var等等

> 除了系统保留关键字之外，Go还提供了一些预定义标识符，其中包括基础数据类型和系统内嵌函数。如：int，float32，string等等。

## 5. 输入输出

Go语言中的键盘输入和输出与C语言十分相像（直接写入地址，所以scanXX系列函数中要使用取地址符&），区别在于使用的是fmt包中的函数。

```go
var str string
// 从标准输入读取一个字符串
fmt.Scan(&str)
fmt.Println(str)
```

## 6. 流程控制

### (1). 分支结构

```go
// if语句的结构
if 表达式1 {
    // 代码块1
} else if 表达式2 {
    // 代码块2
} else {
    // 代码块3
}

// switch语句的结构
switch 待判断表达式 {
// Go语言的switch语句case可以对应多个表达式
// case后面可以是常量，变量，甚至有返回值的函数
// 类型需要和待判断表达式一致
case 表达式1, 表达式2:
    // 代码块1
    // 每一个case的表达式运行完就回退出switch语句
    // 不需要break来退出，如果在这里使用fallthrough，则会继续执行下一个case
case 表达式3, 表达式4:
    // 代码块2
// default语句不是必须的
default:
    // 代码块3
}
// switch的一个特殊用法，类似if-else语句
switch{
case a == 1:
    // .....
case a == 2:
    // ....
}
```

### (2). 循环结构

```go
// for循环
// 打印10句hello world
for i := 0; i < 10; i++ {
    fmt.Println(i, "hello world!")
}
// go中的while循环使用的也是for关键字
for 布尔表达式 {
    // .....
}

// 接下来是go语言中的for-range循环，类似Java中的for-each循环
var str = "hello world"
for index, ch := range str {
    fmt.Printf("str[%d] = %c\n", index, ch)
}

// break的使用和Java中一样，可以配合标签使用指定退出那一层语句块
// continue也是一样的
// goto语句可以无条件进行转移，同C语言
// return就返回整个方法，可以多返回值返回
```
