# 计算机网络面试中常见问题总结

------

[TOC]

------

## 1. 一个网络请求的完整过程

1.  浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器==搜索自身(浏览器)的DNS缓存==、==搜索操作系统的DNS缓存==、==读取本地的Host文件==和==向本地DNS服务器(一般是设定好的服务商提供的
    服务器DNS)进行查询==等。如果要查询的域名曾经解析过,有缓存，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；
    1.  ==递归查询==是指客户端要求本地服务器一定返回一个结果,只发出一次请求.本地服务器查找本地缓存后,查找"根",交由"根"去完成这件事
    1.  ==迭代查询==是指DNS服务器会向自己下属的所有服务器多次发送请求.
1.  浏览器获得域名对应的IP地址(实际上还需要==ARP==协议获得目标服务器的MAC地址,根据MAC地址去传输)以后，浏览器向服务器请求==建立链接==，发起三次握手；
    1.  [ARP协议在同网段及跨网段下的工作原理](https://blog.csdn.net/JAZZSOLDIER/article/details/52635744?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)
    1.  三次挥手细节.....
1.  TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；
1.  ==HTTP请求==报文
    1.  请求行(方法,url,协议版本)
    1.  请求头(附加信息,如:编码,数据格式等等)
    1.  请求体(如post请求的参数)
1.  服务器接收到这个请求，并根据路径参数映射到特定的==请求处理器进行处理==，并将处理结果及相应的视图返回给浏览器；
    1.  中间可能经历负载均衡,Redis,数据库
1.  ==HTTP响应==报文
    1.  状态行(协议版本,状态码1xx表示继续处理,2xx表示成功,3xx表示重定向,4xx表示客户端错误,5xx表示服务端错误,状态码描述)
    1.  响应头,正文类型,编码等等
    1.  空行
    1.  响应数据,返回的内容
1.  ==浏览器解析并渲染视图==，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；
1.  浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

## 2. TCP三次握手建立连接

1.  客户端向服务端发送==请求建立连接的报文==,其中夹杂了一个随机数seq(序号)=x
    1.  客户端从无状态改为等待回应
    1.  SYN = 1,表示是是一个请求或接受连接报文
1.  服务端收到请求后向客户端==发送确认报文段==,发送了一个seq=y,ask(确认号)=x+1
    1.  ==服务端==这时就会为连接==分配内存==,从监听请求改为等待确认的确认的状态
    1.  SYN = 1,表示是是一个请求或接受连接报文
    1.  这个报文和后面的报文中ACK(确认位)都为1,表示报文段有效
1.  客户端收到确认后,向服务端==发送确认的确认==,ack(确认号)=y+1
    1.  ==客户端==这时才会为连接==分配内存==,并从等待匹配请求变为已经建立连接
    1.  服务端也从等待确认的确认表尾已经建立连接

>   之所以要进行三次挥手,是防止服务端不知道客户端什么时候同意了建立连接的请求,有可能客户端已经挂机等等状况.
>
>   还有一个情况就是如果网络状态不好,客户端发的第一个请求连接报文在真正的连接结束后才到达,那么服务端就会多建立一个连接
>
>   SYN泛洪攻击(DDos):
>
>   ​		客户端不断的发送建立连接的请求报文,然后不做指示,就会让服务端为很多无效链接分配很多内存.

## 3. TCP四次挥手断开连接

1.  客户端发送释放连接的报文段
    1.  FIN(终止位)为1,说明这个报文后客户端不再发消息
1.  服务端返回一个响应,并继续传输自己没有传输完的数据
    1.  ACK
    1.  客户端收到这个响应就不能发送数据了
1.  服务端传输完数据后,发送一个连接释放报文段
    1.  ACK
    1.  FIN(终止位)为1,说明这个报文后服务端不再发消息
    1.  服务端发送完这个请求,就不能发送数据了
1.  客户端收到报文后,回复确认报文端,并等待一段时间
    1.  ACK
    1.  等待这段时间是为了防止最后的确认报文丢失了,当服务端长时间没有收到确认时,就会重发3.客户端在这段时间内是可能重复的对3进行确认的

>   让双方都知道一件事情,需要三次通信,但是考虑到服务端还有处理数据,就会多进行一次通信.

## 4. TCP和UDP的区别

1.  TCP面向连接,UDP无连接
1.  TCP可靠交付,UDP不可靠
1.  TCP只支持点到点,UDP支持一对一,一对多,多对多
1.  TCP面向字节流,UDP面向报文
1.  TCP有拥塞控制,适合传输文件,UDP没有,则适合媒体通信(丢少量的包影响不大)
1.  TCP首部开销20字节,UDP 8字节

## 5. TCP如何保障可靠传输

1.  数据包校验
1.  对数据包进行排序(按照确认号)
1.  应答机制(接收端发送确认,说明前面的包都收到了,窗口才会移动)
1.  超时重发(等待一个确认号一定时间后就会重发)

## 6. TCP的流量控制

​		==滑动窗口机制==

​		每次TCP都是在窗口内的包进行发送,一些包到达后(一个积累的过程),接收端就会发送一个确认号,说明这个确认号之前的包都收到了,那么窗口就会移动.

​		每次回复确认号时,都会发送接收方期望的窗口大小(也就是数据的发送速度),发送端根据这个窗口大小实时调整窗口的大小.当窗口为0时,不发送数据.

​		为了防止窗口大小从0重新调整的确认号丢失导致连接故障,发送端收到零窗口通知就会启动一个计时器,计时器到期就会发送请求报文询问此时的窗口大小.

## 7. TCP的拥塞处理

>   拥塞窗口是发送方根据网络的拥塞程度设定的窗口大小,实际的窗口大小是接收窗口和拥塞窗口中的较小值.

1.  慢开始
1.  拥塞避免
    1.  当拥塞窗口大小达到ssthresh时,改为常数增长(+1),在发生网络拥塞时,重新设置ssthresh为此时拥塞窗口大小的一半,并将拥塞窗口大小设为1
1.  快重传
    1.  当收到一个包的三次重复确认后,说明中间发送了丢包现象,立即进行补发
1.  快恢复
    1.  快重传发生的时候也认为此时发生了拥塞,重新设置ssthresh为此时拥塞窗口大小的一半,但是将窗口大小置为ssthresh,也就是快恢复

## 8. HTTPS和HTTP的区别

1.  HTTP协议运行在TCP之上,HTTPS运行在SSL之上,而SSL运行在TCP之上
1.  HTTP端口为80,HTTPS为443
1.  HTTPS由于加减密会速度慢,但是保障安全
1.  HTTPS需要证书,证书需要在CA机构购买

## 9. SSL/TSL连接的建立过程

1.  C端向S端发送请求,连接到S端的443端口.==发送的信息是随机值1和C端支持的加密算法==.
1.  S端收到信息后进行==响应==,包括==随机值2和匹配好的协商加密算法==,这个加密算法是==C端发过来所支持的算法的子集==.
1.  S端发送给C端第二个响应,是==数字证书(自己制作,在ca机构中申请)==,数字证书必须要有一整套.可以自己制作也可以向组织申请(自己制作的证书会在客户端弹出不安全提醒).一整套证书其实就是一对==公钥和私钥==.传送的==证书是其中的公钥==.
1.  C端==解析证书==,这个工作是由客户端的TLS完成的.
    1.  首先会验证公钥是否有效(从 CA 验证该证书的合法性)
    1.  如果没问题,那么==生成一个随机值(预主密钥)==
1.  C端验证证书通过后,==通过随机值1,随机值2和预主密钥组装会话秘钥==.然后==通过证书的公钥加密预主密钥==
1.  传送加密信息==传输的是加密后的会话秘钥==,让==服务端通过解密得到随机值1,随机值2和预主密钥==
1.  服务端==组装==出会话秘钥,应与客户端的会话秘钥一致
1.  客户端通知服务端后面的消息都会只用会话秘钥加密
1.  客户端通过会话秘钥==加密一条数据(前面的握手消息生成摘要)发送给服务端==,验证是否能正常接收消息
1.  服务端通知客户端后面的消息都会使用加密
1.  服务端通过会话秘钥==加密一条消息(握手过程的消息生成摘要)回传给客户端==,如果都能正常接收,那么表明SSL层连接建立完成

## 10. SSL证书的验证过程

[HTTPS的数字证书验证原理](http://blog.csdn.net/liuxingrong666/article/details/83869161?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)

>   ​		证书包括：公钥（Public Key）、ISSUER（证书的发布机构）、Subject（证书持有者）、证书有效期、签名算法、指纹（CA通过指纹算法对证书内容加密后的结果）及指纹算法。
>
>   ​		服务端发送的证书还包括一个签名，是指纹和指纹算法通过CA的密钥进行加密后的结果。
>
>   ​		基本上就是一个验签的过程。总结一下，就是服务端发送的证书中包含证书信息和一个数字签名（证书内容通过CA根证书私钥加密后的结果）。客户端收到后，在颁发机构中找到该证书在CA处的根证书公钥，通过这个根证书就可以对数字签名进行解密，得到指纹和指纹算法，通过加密算法对之前得到的证书登记信息进行再次加密，就可以得到客户端验签的数字签名，如果和之前的数字签名相同，就表示验证成功。

## 11. get和post区别

1.  get意味获取资源,post为提交资源(put修改,delete删除)
1.  get中的参数会放在url(==请求头==)后(英文字母原样发送,其他类型会将其编码为 application/x-www-form-urlencoded MIME 字符串,空格转换为+,其他字符BASE64加密),post会把参数放在==请求体==中(组织方式为application/x-www-form-urlencoded或者JSON,在请求头中有描述)
1.  post请求安全性更高
1.  post请求发送的数据量更多,get请求受限制于url的长度

## 12. Cookie和Session

1.  Cookie将信息存储在客户端,相当于客户端的缓存,Session将信息存储在服务器中
1.  Session依赖Cookie实现,细节是在Cookie中存储了一个SessionID,用这个SessionID从服务器的一个Map中取出Session(也相当一个Map)
1.  Cookie不安全,Session因为保存在服务器上,所以相对安全
1.  Session会增加服务器压力

>   Application是应用全局的属性,所有用户都可以使用

## 13. OSI网络体系

1. 应用层：规定应用进程在通信时所遵循的协议。
2. 表示层：为异种机通信提供一种公共语言，以便能进行互操作。
3. 会话层：管理网络设备的会话连接。
4. 传输层：建立端口到端口的通信。
5. 网络层：IP协议。对应路由器。
6. 数据链路层：把网络层传下来的数据封装成帧。对应网卡，网桥，交换机。
7. 物理层：在传输媒体上传输比特流。对应光缆、电缆、双绞线、无线电波。

下层向上层提供服务,下层的包中封装了上层的包(网络请求是一个不断封装然后传输,最后不断解包得到数据的过程)