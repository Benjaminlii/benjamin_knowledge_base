# 使用docker

[TOC]

---

## run docker常用命令

```shell
# 安装docker略过

# 查看当前已拉取的image
docker image

# 在公共镜像仓库查询image, OFFICIAL表示是否是官方镜像
docker search <image_id>

# 查看现在正在运行的容器,  -a包含未启动的容器
docker ps

# 启动一个容器, 默认为前台启动
# -d: 后台启动
# -i:交互式运行
# -t:容器分配一个伪输入终端, 通常-itd一起使用
# -p <宿主机端口>:<容器端口>: 暴露容器端口到宿主机端口供外部通信 
# --name : 为容器命名
docker run [option] <image_id>[:tag]

# 进入容器
docker exec -it <container_id> <sh_name>

# 启动/停止容器
docker start/stop <container_id>

# 删除已停止容器
docker rm <container_id>
docker rm `docker ps -aq` # 关闭所有已停止容器

# 查看镜像/容器详细信息
docker inspect <image_id/container_id>

# 给镜像创建软连接(同时改名), image_id可以替换image_name:tag
docker tag <old_image_name>:<tag> <old_image_name>:<tag>

# 删除镜像
docker rmi <image_id>

# 在宿主机和容器之间导入导出数据
docker cp <path> <container_id>:<path_in_container>
docker cp <container_id>:<path_in_container> <path>
```

## dockerfile

dockerfile是用于构建镜像的描述文件, docker可以根据dockerfile构建新的镜像。由若干条指令构成, 可以看作是一个简单的脚本。

```dockerfile
# FROM
# 用于定义所构建镜像的基础镜像, 必须为第一条指令
# 	语法: FROM <image>[:<tag>] [AS <name>]
#
# RUN
# 根据此镜像创建容器时执行的命令, 可以有多个.
# 将在当前镜像之上的新图层中执行任何命令并提交结果, 生成一个新的镜像. 即每次执行RUN指令docker都会在基础镜像上包一层, 过多的RUN指令会让镜像膨胀, 一般多条命令用分号分隔使用一条RUN指令执行即可.
# 语法: RUN ["executable", "param1", "param2"]  # 首选形式
#   	 RUN <command>                           # shell形式
#
# COPY
# 创建镜像时可以同时打包文件(从本地向镜像中copy)
# 语法: CMD ["executable","param1","param2"]
#      CMD <command> [param1 param2]
#
# ADD
# 高级版的copy, 在copy的基础上可以进行解压缩(不推荐使用, copy简单点挺好)
#
# EXPOSE
# 声明需要暴露的端口(注意这里仅仅是声明, 真正的暴露在docker run时才会进行, 可以理解为EXPOSE声明后的端口才可能被此镜像创建的容器使用), 可以指定端口是侦听TCP或者UDP, 如果未指定协议, 则默认为TCP.
# 语法: EXPOSE <port> [<port>/<protocol>...]
#
# ENV
# 定义环境变量, 在后续的RUN,CMD中可以使用$varname,${varname}${varname:-default value},$(varname:+default value}这几种方式来使用环境变量 (减号表示env不存在时使用某值,加号表示存在是使用,不存在时也使用,个人理解相当于临时替换吧)
# 语法: ENV <key>=<value> ...
#      ENV <key> <value>        # 单个环境变量可以省略等号
#
# CMD
# 根据此镜像启动容器时执行的命令, 只能有一个命令且须为交互式命令(类似vim, 而非ls), 原因是docker执行时只会保留pid为1的进程, 
# 语法: CMD ["executable","param1","param2"]
#      CMD command [param1] [param2]
#
# ENTRYPOINT
# 和CMD一样, 也是为镜像指定容器启动后的命令. 但不同点在于CMD指令会被docker run时的命令覆盖, 而ENTRYPOINT命令不会, docker run的命令在这种情况下会补充成为ENTRYPOINT指令的参数.
# 例如: dockerfile中ENTRYPOINT ["echo", "hi"], docker run image_name echo /bin/bash 结果会输出 "Hi /bin/bash"
#
# WORKDIR
# 指定后续的RUN,CMD命令在那个目录下执行, 如果不存在则会创建, 相当于CD的用法
# 语法: WORKDIR /path/to/workdir
#

```

