# 一. UML图的总结

------

[TOC]

------

## 1. 基本概念

UML（Unified Modeling Language）即统一建模语言，为面向对象开发系统的产品进行说明、可视化、和编制文档的一种标准语言。下面将对UML的**==九种图+包图==**的基本概念进行介绍以及各个图的使用场景。

UML图分为用例视图、设计视图、进程视图、实现视图和拓扑视图，又可以静动分为静态视图和动态视图。静态图分为：**==用例图，类图，对象图，包图，构件图，部署图==**。动态图分为：**==状态图，活动图，协作图，序列图==**。

![image-20200221125708378](http://benjaminlee.cn:8989/hello/images/image-20200221125708378.png)

## 2. 用例图

用例图用于从用户角度阐述**==软件的各个功能==**和其**==功能的使用者==**.主要使用于需求分析阶段,是非常符合用户思维的设计.

### (1). 用例图所包含的元素

#### 1). 参与者(Actor)

与软件进行交互的用户,组织或者其他外部系统.

![image-20200221125721185](http://benjaminlee.cn:8989/hello/images/image-20200221125721185.png)

#### 2). 用例(Use Case)

用例就是外部可见的系统功能,不包含其内部逻辑实现.这里完全站在不懂技术的用户的角度思考问题.

![image-20200221125736221](http://benjaminlee.cn:8989/hello/images/image-20200221125736221.png)

#### 3). 系统边界

用来分割用例,将用例分割为不同的子系统,子系统内部的功能联系紧密.当然也可以只存在一个完整的系统边界,例如下图.

![image-20200221125746237](http://benjaminlee.cn:8989/hello/images/image-20200221125746237.png)

### (2). 用例图包含的关系

#### 1). 关联

参与者和用例的关系,任何一方都可发送或接受消息.

画法:实线,无箭头.

![image-20200221125753901](http://benjaminlee.cn:8989/hello/images/image-20200221125753901.png)

#### 2). 泛化

可以理解为继承关系.父用例通常是抽象的.

画法:实线,空心三角形箭头,由子用例指向父用例.

![image-20200221125800464](http://benjaminlee.cn:8989/hello/images/image-20200221125800464.png)

#### 3). 包含

将复杂用例划分为较小的步骤,类似程序中的代码封装,主程序中调用子过程.

画法:虚线,线状箭头,标记<\<includes>>,复杂用例指向子过程.

![image-20200221125807176](http://benjaminlee.cn:8989/hello/images/image-20200221125807176.png)

#### 4). 扩展

指用例功能的延伸,相当于为基础用例提供一个附加功能.

画法:虚线,线状箭头,标记<\<extends>>,拓展用例指向主用例.

![image-20200221125814748](http://benjaminlee.cn:8989/hello/images/image-20200221125814748.png)

## 3. 类图

根据用例图抽象出类,用于面向对象程序设计.描述类的内部结构和类与类之间的关系,是一种静态结构图.

### (1). 类图基础属性

#### 1). 类名

#### 2). 属性域

访问级别 字段名 : 类型

#### 3). 方法域

访问级别 方法名(参数) : 返回值类型

>   +表示public
>   -表示private
>   #表示protected
>   ~表示default,也就是包权限
>   _下划线表示static
>   斜体表示抽象

![image-20200221125824615](http://benjaminlee.cn:8989/hello/images/image-20200221125824615.png)

![image-20200221125834459](http://benjaminlee.cn:8989/hello/images/image-20200221125834459.png)

### (2). 类与类之间关系

#### 1). 泛化(Generalization)

表示继承关系或者类对接口的实现关系.Java中即 extends 和 implements 两个关键字.

画法:空心三角形箭头,实线表示继承父类,虚线表示实现接口.箭头指向父类或者接口.

![image-20200221125841984](http://benjaminlee.cn:8989/hello/images/image-20200221125841984.png)

![image-20200221125852110](http://benjaminlee.cn:8989/hello/images/image-20200221125852110.png)

#### 2). 依赖(Dependency)

一个类的实现需要另一个类的协助,如方法的参数,局部变量或者静态方法的调用.

画法:虚线,线状箭头

![image-20200221125900867](http://benjaminlee.cn:8989/hello/images/image-20200221125900867.png)

#### 3). 关联(Association)

一个类知道另一个类,成员变量.

画法:实线,线状箭头,如果为双向关联,则去掉箭头或者双向箭头都可以.箭头指向成员变量

![image-20200221125917549](http://benjaminlee.cn:8989/hello/images/image-20200221125917549.png)

#### 4). 聚合(Aggregation)

整体与部分的关系,是一种弱的‘拥有’关系,**==部分可以独立存在==**.是关联的一种,语法上无发区分,需要依赖逻辑区分.**两个对象具有各自的生命周期**.

画法:在关联的基础上,加空心菱形.

![image-20200221125927282](http://benjaminlee.cn:8989/hello/images/image-20200221125927282.png)

#### 5). 组合(Composition)

同样是整体和部分的关系,这里是强"拥有"关系,部分不可以独立存在,是关联的一种.**部分和整体的生命周期一样**.

画法:关联的基础上,加实心菱形.

![image-20200221125938182](http://benjaminlee.cn:8989/hello/images/image-20200221125938182.png)

## 4. 对象图

### (1). 概念

描述参与交互的**==各个对象==**在交互过程中的**==某时刻的状态==**(所以只有属性,不包含方法),可以看做是类图在某一时刻的快照.表示对象之间的特定关系.

不包含对象的方法,名称栏新增对象名.属性栏中为当前值.

![image-20200221125945300](http://benjaminlee.cn:8989/hello/images/image-20200221125945300.png)

对象图中的建模元素主要有对象和链(所有关系统一使用实现来表示,不加以区分)，对象是类的实例，链是类之间的关联关系的实例。

![image-20200221125954706](http://benjaminlee.cn:8989/hello/images/image-20200221125954706.png)

## 5. 状态图

一种由**==状态,变迁,事件和活动==**组成的自动机.用来描述类的对象所有可能的状态以及状态转移条件.

### (1). 组成元素

-   状态：圆角矩形,文字叙述其状态内容
-   转移：箭头,文字叙述转移条件
-   起点：一个黑点 
-   终点：一个圈加一个黑点 

### (2). 状态机

描述了系统从一个状态响应一个事件后达到另一个状态的一系列行为.

![image-20200221130003547](http://benjaminlee.cn:8989/hello/images/image-20200221130003547.png)

## 6. 活动图

### (1). 概念

是状态图的特殊情况,所有的状态都处于活动状态,**==本质上是一种流程图==**.支持并发进程.

### (2). 组成元素

#### 1). 起点

实心黑色圆点.

#### 2). 终点

圆圈加内部实心黑色圆点.

#### 3). 动作状态

是指原子的不可中断的动作，并在此动作完成后通过完成转换转向另一个状态.

#### 4). 动作流

动作之间的转换，用带箭头的直线表示，箭头的方向指向转入的方向

#### 5). 分支与合并

菱形表示,由一个箭头指向分支符号(转换),一个或者多个箭头从分支符号指向外(离开转换).每一个离开转换都对应一个监护条件.满足条件才能执行该转换.

![image-20200221130021571](http://benjaminlee.cn:8989/hello/images/image-20200221130021571.png)

#### 6). 分叉与汇合

动作流分为两个或者多个并发运行的分支.

![image-20200221130033480](http://benjaminlee.cn:8989/hello/images/image-20200221130033480.png)

#### 7). 泳道

将活动图中的活动划分为若干组，并把每一个组指定个负责这组活动的业务组织，即对象。在活动图中，泳道区分了负责活动的对象，它明确的表示了哪些活动是由哪些对象进行的，在包含泳道的活动图中，每个活动只能明确的属于一个泳道

![image-20200221133050139](http://benjaminlee.cn:8989/hello/images/image-20200221133050139.png)

![image-20200221133115719](http://benjaminlee.cn:8989/hello/images/image-20200221133115719.png)

## 7. 时序图(序列图)

### (1). 概念

交互图的一种,描述了对象之间消息发送的先后顺序,强调时间顺序.

### (2). 组成元素

#### 1). 角色

程序外的其他人或者其他系统.

#### 2). 对象

位于时序图的顶部,是一个矩形框.表示处理响应步骤的处理者.

#### 3). 生命线

角色和对象都有一条向下的生命线,是一条虚线.

![image-20200221133128396](http://benjaminlee.cn:8989/hello/images/image-20200221133128396.png)

#### 4). 控制焦点

生命线上的窄矩形框,代表生命周期中这段时间处于激活状态.

#### 5). 消息

代表对象之间发送的信息.分为三种:

- 同步消息:会等待返回消息.使用实线+实心箭头表示.
![image-20200221133148651](http://benjaminlee.cn:8989/hello/images/image-20200221133148651.png)
- 异步消息:不进行等待,发完消息后继续自己的活动,使用并发完成.使用实线+线状箭头表示.
![image-20200221133223406](http://benjaminlee.cn:8989/hello/images/image-20200221133223406.png)
-   返回消息:对消息的回应,相当于返回值.使用虚线+线状箭头表示.

![image-20200221133251027](http://benjaminlee.cn:8989/hello/images/image-20200221133251027.png)

## 8. 协作图(通信图)

### (1). 概念

交互图的一种.按照空间结构布图,而非时序图的时间结构.

协作图与时序图在语义上是等价的，二者可以相互转换，而不会丢失信息。

![image-20200221133307923](http://benjaminlee.cn:8989/hello/images/image-20200221133307923.png)

![image-20200221133318971](http://benjaminlee.cn:8989/hello/images/image-20200221133318971.png)

### (2). 组成元素

#### 1). 对象

![image-20200221133332162](http://benjaminlee.cn:8989/hello/images/image-20200221133332162.png)

#### 2). 链接

用来关联对象,使用无箭头的实线链接.

#### 3). 消息

消息是协作图中对象与对象之间通信的方式

![image-20200221133342263](http://benjaminlee.cn:8989/hello/images/image-20200221133342263.png)

## 9. 构件图

本小节总结自:[UML构件图](https://blog.csdn.net/soft_zzti/article/details/80331932)

### (1). 概念

构件图也叫组件图,由构件,接口和构件之间的关系构成

用来表示系统中构件与构件之间,类或者接口与构件之间的关系.(构件是系统中可替换的物理部分，它包装了实现而且遵从并提供一组接口的实现)

其中构件之间的关系为依赖,类或接口与构件之间的关系为依赖或者实线.

### (2). 组成元素

#### 1). 构件

构件是实现接口的物理单元,是可替换的.是软件,类似于jar包,可执行文件,库,文件,文档等.

构件通过它提供的接口和请求展现行为.

表示方式:

![image-20200221133354379](http://benjaminlee.cn:8989/hello/images/image-20200221133354379.png)

![image-20200221133416119](http://benjaminlee.cn:8989/hello/images/image-20200221133416119.png)

#### 2). 接口

由一组操作组成,是构件的一部分,分为提供接口和请求接口;

##### 提供接口

意味着该接口是向其他构件提供功能的.实现接口的构件支持该接口中的所有功能.

使用棒棒糖图标表示.

Java中显示表示为 implements 关键字;

##### 请求接口

指该构件向其他构件请求服务时需要的遵循的接口.

要使用接口所需要的条件,对应另外一个提供接口.比如内部有一个接口的成员变量或者方法传参.

使用插座式图标表示.

![image-20200221133430012](http://benjaminlee.cn:8989/hello/images/image-20200221133430012.png)

#### 3). 端口

是构件的一部分,所有进出构件的交互都要通过端口,也就是说,所有接口都需要通过端口实现.

##### 与接口的关系

一个构件可以通过一个特定端口同另一个构件通讯，而且通讯完全是通过由端口支持的接口来描述的。

##### 表示

在接口的尾部加小方框,这个小方框就代表端口.

![image-20200221133442868](http://benjaminlee.cn:8989/hello/images/image-20200221133442868.png)

#### 4). 连接器

##### 组件连接器

组件连接器是两个构件实例间的连接件，它定义一个构件实例提供服务，另一个构件实例使用这些服务

显示的单纯表示连接可以用一条实线表示(直接连接器),而通过接口实现的连接则需要通过棒棒糖图标和插座图标的结合表示.

![image-20200221133452923](http://benjaminlee.cn:8989/hello/images/image-20200221133452923.png)

##### 委托连接器

委托连接件把外部对构件端口的请求分发到构件内部的部件实例进行处理，或者通过构件端口把构件内部部件实例向构件外部的请求分发出去。

用于组件和其内部组件的连接.

注明一点,委托连接器适用于构件内部的部件.

![5](http://benjaminlee.cn:8989/hello/images/5.png)

**注意事项**：因为构i件是可以嵌套的，所以内部构件之间的连接（球-穴）是组装连接件，内部构件与端口之间的连接（实线箭头）是委托连接件。

#### 5). 依赖关系

与类图中的依赖关系相同.都是由客户指向提供者的虚线箭头.

![image-20200221133525725](http://benjaminlee.cn:8989/hello/images/image-20200221133525725.png)

## 10. 部署图

### (1). 概念

部署图描述的是系统程序运行时的结构,展示了硬件配置和相关的网络结构.

一个系统只有一个部署图,往往被用来描述分布式系统.

用于展示系统软件和硬件的拓扑结构.清晰的说明系统的使用部署,环境等情况.

### (2). 组成元素

#### 1). 结点

代表计算机上的物理资源,可以是硬件(外设),也可以是软件资源(防火墙,数据库).

使用三维的盒子表示.

![image-20200221133537218](http://benjaminlee.cn:8989/hello/images/image-20200221133537218.png)

#### 2). 结点实例

与结点的区别在于冒号加名称.

![image-20200221133546217](http://benjaminlee.cn:8989/hello/images/image-20200221133546217.png)

#### 3). 结点类型

结点类型有：«cdrom», «cd-rom», «computer», «disk array», «pc», «pc client», «pc server», «secure», «server», «storage», «unix server», «user pc»，并在结点的右上角用不同的图标表示，如下图

![image-20200221133557249](http://benjaminlee.cn:8989/hello/images/image-20200221133557249.png)

#### 4). 物件

软件开发过程中的产物,如UML图,源代码,设计文档等等.

表示如下,带有关键字<\<artifact>>和文档图标:

![image-20200221133611093](http://benjaminlee.cn:8989/hello/images/image-20200221133611093.png)

#### 5). 连接

结点之间的连线表示系统之间进行交互的通信路径,被称为连接.

![image-20200221133621612](http://benjaminlee.cn:8989/hello/images/image-20200221133621612.png)

#### 6). 结点容器

一个结点包含了其他结点,那么称这个结点为结点容器.

## 11. 各种图的差异比较

### (1). 时序图 VS 协作图

这两个图都是交互图,语义上等价,可以相互转化,但是则重点不同.

顾名思义,时序图侧重时间上的先后顺序,协作图则侧重于对象间的协作关系(空间结构).

### (2). 状态图 VS 活动图

二者都是行为图.

状态图侧重状态改变的结果(行为驱动而已),而活动图侧重于改变状态的行为.

活动图并不是必须的,满足以下条件时才有必要绘制:

-   出现并行或则并发行为
-   描述算法(侧重于行为)
-   跨越多个用例(只侧重于结果描述可能表达不清楚)

### (3). 活动图 VS 交互图(时序图和协作图)

都涉及到对象和对象之间传递的消息.

交互图观察的是传送消息的对象,而活动图观察的是传送的消息(事件之间活动的逻辑关系中包含了消息的内容).
