# 第三章 应用层

-----

[TOC]

-----

## 1. DNS系统

IP地址难以记忆,所以出现了域名来一对一的对IP地址进行映射.

在发送一个请求时,我们输入的是域名,然后与一台或多台DNS服务器进行访问,DNS服务器会将域名转化为对应主机的IP地址返回回来.然后我们的主机在使用得到的IP地址进行访问.

[DNS 服务原理详解 - 简书](https://www.jianshu.com/p/4394aaf97492)

DNS 是一个树状的结构：

![image-20200221133923029](http://benjaminlee.cn:8989/hello/images/image-20200221133923029.png)

在“根域”这里，只关心“一级域名”的情况，记录了如 com、net、org 这几个域名分区的负责人的信息。

### (1). 两种查找模型

#### 1). 层级递归查询

A -> B -> C -> D

A 问 B，B不知道，但 B 知道 C 知道，于是B问C，C也不知道，但C知道D知道。
 逐级查询，逐级返回。

#### 2). 迭代查询

A -> B
 A -> C
 A -> D

A 问 B，B不知道，但 B 知道 C 知道，于是A去问C，C也不知道，但C知道D知
 道，于是A去问D。

真正的DNS查询使用的哪种模式? 互联网上的绝大多数查找模型都是迭代的。**但 DNS 是递归+迭代的，是先递归，后迭代的。**

### (2). 真正域名查询的过程

真正域名查询的过程是: 先递归，后迭代。

比如当客户端查询 www.qq.com 的时候，不是直接去找根的，你想一下配置网络地址时，你的DNS服务器填写的是什么，一般是本地的一个服务器，可能是公司内部的一个服务器，如果公司没有，你的宽带运营商一定会提供一个DNS服务器地址。

在DNS的模型中，上级知道下级，但下级不知道自己的上级是谁，虽然知道自己在哪个域名内，但那个域名的管理者(服务器)是谁，其实是不知道的。

当我们请求域名解析时，把请求发送到本地的某个DNS服务器，如果是请求解析 “[www.qq.com](https://link.jianshu.com?t=http://www.qq.com)”，当DNS服务器要查询一个非本地管理的域名时，会去找“根”。每一个DNS服务器都预先设置了“根”的地址，大部分默认法则，它们仅知道”根”的IP地址，并不知道其他一级域名管理者的地址。

“根” 返回说查询的主机名归 com 管理，返回 com 的管理者地址，本地的DNS服务就去 com 的服务器进行查询。com 返回说归 [qq.com](https://link.jianshu.com?t=http://qq.com) 的二级域名管理者管理，于是本地DNS又去查询 [qq.com](https://link.jianshu.com?t=http://qq.com) 这个域名的管理者的域名服务器，最终得到 [www.qq.com](https://link.jianshu.com?t=http://www.qq.com) 的IP地址，返回给客户端。

==客户端到本地 DNS 这一步，是“递归查询”的方式，要求 DNS 服务器必须返回结果，只发出一次请求。DNS 服务器进行查询的方式，是“迭代查询”的方式，可能多次发起查询请求。==

## 2. HTTP协议

HTTP协议规定了浏览器如何向服务器请求资源和服务器如何向浏览器发送资源.

服务器监听80端口,发现所有访问服务器的请求,一旦服务器监听到请求,并且成功建立连接,浏览器就可以发送HTTP请求报文,服务器接收到HTTP请求报文之后根据自身的逻辑准备资源,并将资源通过HTTP响应报文发送给客户端.最后释放TCP连接.

### (1). HTTP的特点

-   无状态:用一个客户两次访问服务器时服务器的HTTP响应是没有区别的.
    -   通过cookie使得HTTP请求可以记录信息,是记录在用户主机中的文本文件
-   采用TCP协议作为传输层协议,但HTTP本身是无连接的

### (2). HTTP报文结构

分为请求报文和响应报文.

HTTP报文是面向文本的,因此报文中每一个字段都是ASCII码串

![1574517235838](http://benjaminlee.cn:8989/hello/images/1574517235838.png)

#### 1). 请求行

方法就是该请求要对资源进行的操作

- GET:用于获取服务器中的资源

- POST:用于创建一个资源

- PUT:用于修改一个资源

- DELETE:用于删除一个资源

版本是HTTP协议的版本

#### 2). 首部字段

首部行(请求头,响应头)

使用Key:value的方式保存数据:

-   字符集:Accept-Charset
-   正文的格式:Content-Type
-   .
-   .
-   .

响应报文中的状态码就是404,500,200那一堆东西:

-   1xx:通知信息,如请求正在处理等
-   2xx:请求成功
-   3xx:重定向
-   4xx:客户出现差错
-   5xx:服务器出现差错

#### 3). 正文

这部分放置要传输的数据(买什么,买多少)

## 3. HTTP请求的发送

HTTP协议是基于TCP协议的,通过二进制流将数据传给对方时,在TCP层会按照TCP协议把二进制流变成一个一个报文发送给对方.

每发送一个报文段,都需要对方回应一个确认号ack,保证这个确认号之前的数据全部收到了.

TCP在发送每一个报文的时候,都需要加上源地址,源端口号,目标地址和目标端口号,将这些信息放入IP头中,交给IP层进行传输.

IP层需要查看目标地址是否和自己在一个局域网中,如果在,就发送ARP协议来请求这个目标地址对应的MAC地址,将源MAC地址和目标MAC地址放入MAC头,发送出去.

>   网络层的ARP协议工作原理:
>
>   网络层的ARP协议完成了IP地址与物理地址的映射。
>
>   首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。
>
>   当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。
>
>   此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

如果不在一个局域网,需要将这个IP包发送到网关,先发送ARP协议请求网关的MAC地址,然后步骤和之前类似.

一层一层的跳跃后,终于达到了目标地址的局域网,找到目标的MAC地址,然后发送出去.

目标机器发现MAC地址符合,就将包收起来.发现IP地址符合,就拆包到TCP层.TCP层分发到指定端口后验证序列号,发现序号是不是当前需要的,如果是就返回一个ACK.如果不是,就丢弃包.

## 4. HTTP协议各个版本

[参考博客:从HTTP/0.9到HTTP/2：一文读懂HTTP协议的历史演变和设计思路](https://www.cnblogs.com/imstudy/p/9234124.html)

### (1). HTTP 0.9

最原始的HTTP协议,每一个请求都要经历TCP连接的建立和断开.

只有一个GET方法.只能回复HTML格式的字符串.

### (2). HTTP 1.0

任何格式都可以发送了(文字,图像,视频,二进制)

加入了POST和HEAD方法

加入了请求头,描述元数据

### (3). HTTP 1.1

引入了持久连接,也就是TCP连接默认是不关闭的,可以被多个HTTP请求复用.客户端和服务端一段时间没有互动后才会主动断开连接.

引入了管道机制,在同一个TCP连接里面,可以同时发送多个请求.但请求的回复还是按顺序回复的.

### (4). HTTP 2

二进制协议,在之前HTTP 1.1版本的头信息是文本(ASCII编码),数据体可以使文本也可以是二进制.而HTTP 2之后,头信息和数据体都是二进制的.统称为帧.

客户端可以同时发送多个请求或者回应,而且不用按照顺序一一对应.也就是异步性.为了实现这个功能,HTTP 2为每个数据包添加了唯一的编号,用编号来唯一对应请求包和响应包.

头信息压缩.一方面,头信息使用gzip等方式压缩后再发送,另一方面客户端和服务端都会维护一个存储了头信息的表,所有字段都对应一个索引号.每次只发送其中的索引号.

## 5. HTTPS协议

基于HTTP协议,通过SSL或者TLS提供加密处理数据,验证身份以及数据完整性保护.

内容加密:采用混合加密技术,中间者不能查看明文内容

验证身份:通过证书认证客户端访问的是自己的服务器.

保护数据完整性:防止传出的内容被中间人冒充或修改

### (1). SSL/TSL握手过程

1.  C端向S端发送请求,连接到S端的443端口.==发送的信息是随机值1和C端支持的加密算法==.
1.  S端收到信息后进行==响应==,包括==随机值2和匹配好的协商加密算法==,这个加密算法是==C端发过来所支持的算法的子集==.
1.  S端发送给C端第二个响应,是==数字证书(自己制作,在ca机构中申请)==,数字证书必须要有一整套.可以自己制作也可以向组织申请(自己制作的证书会在客户端弹出不安全提醒).一整套证书其实就是一对==公钥和私钥==.传送的==证书是其中的公钥==.
1.  C端==解析证书==,这个工作是由客户端的TLS完成的.
    1.  首先会验证公钥是否有效(从 CA 验证该证书的合法性)
    1.  如果没问题,那么==生成一个随机值(预主密钥)==
1.  C端验证证书通过后,==通过随机值1,随机值2和预主密钥组装会话秘钥==.然后==通过证书的公钥加密会话秘钥==
1.  传送加密信息==传输的是加密后的会话秘钥==,让==服务端通过解密得到随机值1,随机值2和预主密钥==
1.  服务端==组装==出会话秘钥,应与客户端的会话秘钥一致
1.  客户端通知服务端后面的消息都会只用会话秘钥加密
1.  客户端通过会话秘钥==加密一条数据(前面的握手消息生成摘要)发送给服务端==,验证是否能正常接收消息
1.  服务端通知客户端后面的消息都会使用加密
1.  服务端通过会话秘钥==加密一条消息(握手过程的消息生成摘要)回传给客户端==,如果都能正常接收,那么表明SSL层连接建立完成

### (2). 双向验证

双方已安全地协商出了同一份密钥，将所有的应用层数据都用这个密钥加密过后再通过TCP进行可靠传输

### (3). 握手过程优化

如果每次重连都要重新握手，那么显然会浪费大量的资源和时间。所以我们不妨在Client Hello(客户端首先发送的消息)消息中附带上上一次的Session ID。服务端接收到这个Session ID后若能复用就不再进行后续的握手过程

### (2) 对称加密与非对称加密

对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的==公钥进行加密==处理，对方接收到加密信息后，使用自己的==私钥进行解密==。

由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。

