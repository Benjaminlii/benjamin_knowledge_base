# Redis

## Redis的使用场景

答：
缓存，分布式session，分布式锁，计数器（incr方法原子性自增一），消息队列，布隆过滤器

## 如何解决redis的缓存失效雪崩问题

答：
缓存穿透：查询不存在的数据时，永远都不会命中缓存，直接打到DB上，DB中没有存储这个Key就不会写入缓存。解决办法：对这个查询条件设置一个生效时间比较短的空值缓，布隆过滤器。
缓存雪崩：指在高并发场景中，同一时刻有大量的Key失效或者redis宕机，会导致大量并发打到DB中导致DB压力过大性能下降甚至DB宕机。解决办法：随机的过期时间，多级缓存，缓存失效后限流。
缓存击穿：指在高并发场景中，一个热key失效后会立刻导致大量请求打到DB。解决办法：在请求没有命中缓存转而访问DB时，加一个分布式互斥锁，并发的大量请求中只有一个能获取锁，DB查询到数据并写入缓存后释放。其他请求获取不到锁自旋等待锁，获取到锁后再次访问缓存。

## Redis的分布式锁如何保证解锁和加锁是同一个线程？

eg：网络延迟情况下超时自动解锁后，第二个线程加上了锁，这时第一个线程解锁会解第二个线程的锁
答：
思路一：加锁时启动一个协程，无限的给这个锁续借，当主协程退出时这个续借协程也退出。
思路二：加锁时将当前请求的ID设置为锁的value，解锁时使用lua脚本保证原子性的执行查询判断是否是当前请求加锁并解锁。

## redis的持久化机制

答：
RDB:即Redis DataBase.就是将Redis中的数据写入磁盘中，会生成多个快照文件，每一个都存储了Redis中某一时刻的数据。优点是存储文件小，存储时在自线程中执行，不会暂停服务，恢复速度快。缺点是最多只能恢复到最新的文件中的数据，丢失的数据相对较多。
AOF:即Append-Only File.字面意思是只可追加的文件,也就是以重做日志的方式去存储Redis中数据的变化，会将Redis执行的数据变更都记录下来，并会自行进行合并。优点是最优情况下不丢失数据（这种情况下是由主线程执行的，性能会差很多，每秒同步则是通过子线程执行，相对性能较好，但会丢失一秒的数据）。缺点是存储文件较大，恢复比较慢
